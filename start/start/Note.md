参考链接：[OSDev Wiki](https://wiki.osdev.org/Main_Page)

## Q：如何从16位实模式进入32位保护模式？

> A：需要将CR0的PE位置一，但是前后需要一些操作，如下：
> 
> 1. 关中断：防止运行中途发生中断，程序运行出现异常
> 2. 打开A20地址线：为保证和之前的16位兼容，默认不开启，无法访问4GB内存空间
> 3. 加载GDT表：某种重要的配置数据
> 4. 设置CR0，PE=1，开启保护模式使能位
> 5. 远跳转：清空原来的流水线，取消原16位的指令

## Q：32位保护模式下如何读取磁盘？

> A：使用LBA模式
> 在32保护模式下，BIOS的16位软中断指令无法执行，读取磁盘需要用到LBA模式
> LBA模式下没有磁盘柱面的概念，扇区起始编号为0，依次增加
>
> *参考：[ATA PIO Mode - OSDev Wiki](https://wiki.osdev.org/ATA_PIO_Mode)*

## Q：如何向内核传递

> A：已经在loader中将内存的信息读取到结构体boot_info中了可有以下三种方式：
>
> 1. 将boot_info写到内存中某个固定的地址，再由kernel自行读取。
>
>    *缺点：需要事先约定，当后续存储规划发生变化时，需要同时调整两部分的代码*
>
>2. 将内核的入口地址处视为存放着一个接收启动信息的函数，使用函数调用`((void) (*) (boot_info_t *))(SYS_KERNEL_LOAD_ADDR)(&boot_info)`来传递参数
>
>    *特点：不需要考虑内存位置，但是需要了解一下函数调用时参数传递的知识*
>
>3. 